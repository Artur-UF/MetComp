# -*- coding: utf-8 -*-
"""Aula_Python_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nbzsiyDUrHu0v-eUpwgQyl2FZlk-rnzv

# Entradas e saídas

Muitas vezes desejamos ter mais controle sobre a formatação da saída do que simplesmente exibir valores separados por espaço. Existem várias maneiras de formatar a saída. Para mais detalhes e outras opções, consulte https://docs.python.org/pt-br/3/tutorial/inputoutput.html

**Strings formatadas**

Strings literais formatadas (f-strings) permitem incluir o valor de expressões Python dentro de uma string. Para isso é preciso usar f ou F antes da string e escrever expressões na forma {expression}.
"""

cor = 'verde'
print(f'Minha cor favorita é {cor}.')

import math
print(f'O valor de pi é aproximadamente {math.pi:.6f}.')

"""**Método format()**"""

print('Minhas cores favoritas são {} e {}.'.format('verde', 'azul'))

# Acessando argumentos pelo nome
print('Coordenadas de Porto Alegre: {latitude}, {latitude}'.format(latitude='-30.0277S', longitude='-51.2287W'))

# Acessando argumentos pela posição
print('Coordenadas de Porto Alegre: {1}, {1}'.format('-30.0277S', '-51.2287W'))

for x in range(20):
  print('{0:2d} {1:3d} {2:4d}'.format(x, x**2, x**3))

print('O valor aproximado de pi é {0:.8f}'.format(math.pi))

y = -0.16
print('{0:.1f} {1:.2f} {2:.4f}'.format(y,y,y))

"""Para mais detalhes e informações: https://docs.python.org/pt-br/3/library/string.html#formatstrings

**Formatação manual**
"""

# mesma tabela de quadrados e cubos anterior, agora formatados manualmente:
for x in range(20):
  print(repr(x).rjust(2), repr(x*x).ljust(3), end=' ')
  print(repr(x*x*x).center(4))

# A função repr() retorna uma string contendo uma representação imprimível de um objeto.
# O método str.rjust() justifica uma string à direita, num campo de tamanho definido, acrescentando
# espaços à esquerda. Similarmente, o método str.ljust() justifica à esquerda e o método
# str.center() pode ser usado para centralizar.

# O método str.zfill() preenche uma string numérica com zeros à esquerda. Note que ele lida com sinais positivos e negativos.
'21'.zfill(8)

'-3.14'.zfill(7)

'3.14159'.zfill(3)

"""**Formatação à moda antiga**

"""

quant = 1
objeto = 'gasolina'
valor = 6.36

print('%d litro de %s custa R$ %.1f' %(quant,objeto,valor))

"""Mais detalhes e informações em https://docs.python.org/pt-br/3/library/stdtypes.html#old-string-formatting

Nota: as peculiaridades da formatação 'à moda antiga' podem levar a diversos erros comuns (tais como não conseguir exibir tuplas e dicionários corretamente). O novo formatador de string literal (f-strings) e a interface str.format() fodem ajudar a evitar esses erros.

# Leitura e escrita de arquivos

A função open() devolve um objeto arquivo (file object) e é frequentemente usada com dois argumentos: open(nome_do_arquivo, modo). O primeiro argumento é uma string contendo o nome do arquivo. O segundo argumento é outra string, contendo alguns caracteres que descrevem o modo como o arquivo será usado:
* 'r' para apenas ler
* 'w' para escrever (se o arquivo já existir seu conteúdo será apagado)
* 'a' para abrir para adição
* 'r+' abre o arquivo tanto para leitura como para escrita

Qualquer escrita será adicionada ao final do arquivo. O argumento padrão para o modo é 'r'.
"""

f = open('input_output.txt', 'r')

f.read()

"""Linhas em branco são representadas por um '\n', uma string contendo apenas o caractere terminador de linha."""

# Se o fim do arquivo for atingido, f.read() devolve uma string vazia ('').
f.read()

# para fechar um arquivo
f.close()

"""O método f.readline() lê uma única linha do arquivo."""

# abrindo o arquivo novamente
f = open('input_output.txt', 'r')

f.readline()

f.readline()

f.close()

"""Uma maneira alternativa de ler linhas do arquivo é iterar diretamente pelo objeto arquivo:"""

f = open('input_output.txt', 'r')
for line in f:
  print(line, end='')

f.close()

"""Para ler todas as linhas de um arquivo em uma lista, pode-se usar """

f = open('input_output.txt', 'r')
list(f)

f.close()

f = open('input_output.txt', 'r')
f.readlines()

f.close()

"""Podemos separar os elementos de uma string usando o método split:"""

# abrindo o arquivo novamente
f = open('input_output.txt', 'r')
linha = f.readline()
print(linha)

palavras = linha.split(sep=None)
print(palavras)

"""f.write(string) escreve o a string para o arquivo, retornando o número de caracteres escritos"""

f = open('input_output.txt','a')
f.write('Adicionando uma linha ao arquivo.\n')

f.close()

# Cuidado com o modo 'w'
f = open('input_output.txt','w')
f.write('Adicionando uma linha ao arquivo.\n')

f.close()

import numpy as np

# Criando um array
a = np.arange(0,1,0.1)
print(a)

output = open('saida.txt', 'w')
# Note que se o arquivo não existir, ele será criado.

for i in range(len(a)):
  output.write('{0:2d}  {1:.2f}\n'.format(i,a[i]))

output.close()

"""Utilizando o método loadtxt do numpy para ler um arquivo de texto com dados. Cada linha do arquivo de texto deve ter a mesma quantidade de valores."""

import numpy as np
col1,col2 = np.loadtxt('saida.txt',unpack=True)
print(col1,col2)

valores = np.loadtxt('saida.txt',unpack=False)
print(valores)

"""Utilizando o readlines e str.split() para ler o mesmo arquivo:"""

arquivo = open('saida.txt', 'r')
#criando listas vazias para armazenar os valores das 2 colunas do arquivo
coluna1 = []
coluna2 = []

for line in arquivo:
  coluna1.append(int(line.split(sep=None)[0]))  #separando os elementos da linha
                                                #e colocando o de índice 0
                                                #(transformado para inteiro) na lista coluna1
  coluna2.append(float(line.split(sep=None)[1]))#separando os elementos da linha
                                                #e colocando o de índice 1
                                                #(transformado para float) na lista coluna2

arquivo.close()
print(coluna1,coluna2)